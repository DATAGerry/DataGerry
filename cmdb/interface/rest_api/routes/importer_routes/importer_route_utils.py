# DATAGERRY - OpenSource Enterprise CMDB
# Copyright (C) 2025 becon GmbH
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
"""
Implementation of Importer API routes helper methods
"""
import json
import logging
from typing import Union
from flask import request, abort
from werkzeug.datastructures import FileStorage
from werkzeug.utils import secure_filename
from werkzeug.wrappers import Request

from cmdb.manager.query_builder import BuilderParameters
from cmdb.manager import TypesManager

from cmdb.framework.importer.helper.importer_helper import load_parser_class
from cmdb.models.user_model import CmdbUser
from cmdb.models.type_model import CmdbType
from cmdb.security.acl.permission import AccessControlPermission

from cmdb.errors.security import AccessDeniedError
# -------------------------------------------------------------------------------------------------------------------- #

LOGGER = logging.getLogger(__name__)

# -------------------------------------------------------------------------------------------------------------------- #

def get_file_in_request(file_name: str, request_files) -> FileStorage:
    """
    Retrieve a file from the incoming request by its field name.

    Args:
        file_name (str): The name of the file field expected in the request.
        request_files (ImmutableMultiDict): The collection of files attached to the request.

    Raises:
        400 Bad Request: If the specified file is not found in the request

    Returns:
        FileStorage: The uploaded file object.
    """
    if file_name not in request_files:
        LOGGER.error('File with name: %s was not provided', file_name)
        abort(400, "No file provided in the request!")

    return request.files.get(file_name)


def get_element_from_data_request(element, _request: Request) -> Union[dict, None]:
    """
    Extract and parse a specific form field from the request as a JSON object

    Args:
        element (str): The name of the form field to extract
        _request (Request): The Flask request object containing the form data

    Returns:
        dict or None: The parsed JSON object if successful, otherwise None
    """
    try:
        return json.loads(_request.form.to_dict()[element])
    except (KeyError, Exception):
        return None


def generate_parsed_output(request_file, file_format, parser_config):
    """
    Save an uploaded file and parse its content using a format-specific parser

    Args:
        request_file (FileStorage): The uploaded file to parse
        file_format (str): The format of the file (e.g., 'json', 'csv') used to select the parser
        parser_config (dict): Configuration settings passed to the parser

    Returns:
        Any: The parsed output generated by the parser
    """
    # Load parser class
    parser_class = load_parser_class('object', file_format)

    # save file
    filename = secure_filename(request_file.filename)
    working_file = f'/tmp/{filename}'
    request_file.save(working_file)

    # parse content
    parser = parser_class(parser_config)
    output = parser.parse(working_file)

    return output


def verify_import_access(user: CmdbUser, _type: CmdbType, types_manager: TypesManager) -> None:
    """
    Validate if a user has access to objects of this type
    """
    location = 'acl.groups.includes.' + str(user.group_id)
    query = {'$and': [{'$or': [
        {'$or': [
            {'acl': {'$exists': False}}, {'acl.activated': False}]
        },
        {'$and': [
            {'acl.activated': True},
            {'$and': [
                {location: {'$exists': True}},
                {location: {'$all':
                        [
                            AccessControlPermission.READ.value,
                            AccessControlPermission.CREATE.value,
                            AccessControlPermission.UPDATE.value
                        ]
                    }
                }
            ]
            }
        ]
        }]
    }, {'public_id': _type.public_id}]}

    builder_params = BuilderParameters(criteria=query, limit=1)

    types_ = types_manager.iterate(builder_params)

    if len([CmdbType.to_json(_) for _ in types_.results]) == 0:
        raise AccessDeniedError(f'The objects of the type `{_type.name}` are protected by ACL permission!')
